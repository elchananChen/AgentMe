שלב א': התשתית הסטטית (הגישה הנקייה)
כאן המטרה היא לגרום לסוכן להבין "מי אתה" בצורה מושלמת בלי לוגיקה מסובכת.

משימה 1: בניית ה-knowledge.md

יצירת קובץ Markdown אחד שמרכז את קורות החיים שלך + תיאור של 2-3 פרויקטים מובילים (מטרת הפרויקט, אתגרים טכניים, והפתרון).

משימה 2: יצירת ה-Context Route

כתיבת קוד ב-app.ts שקורא את הקובץ הזה מהדיסק (באמצעות fs.promises.readFile) ומזריק אותו כ-system prompt.

בדיקה: שלח שאלה ב-Postman כמו "באיזה פרויקט השתמשת ב-Redis?" וראה אם הוא עונה לפי הקובץ.

שלב ב': הגישה הדינמית (GitHub Agent)
כאן אנחנו הופכים את הסוכן ל"חי" ומחובר לעולם.

משימה 3: חיבור ל-GitHub API

הוצאת Personal Access Token מ-GitHub.

התקנת חבילת octokit (הלקוח הרשמי של GitHub ל-Node.js).

כתיבת פונקציה פשוטה שמקבלת owner, repo ו-path ומחזירה את תוכן הקובץ כטקסט.

משימה 4: הגדרת ה-Tool הראשון (read_file)

שימוש ב-tool מה-Vercel AI SDK כדי להגדיר לסוכן איך להשתמש בפונקציה מהמשימה הקודמת.

הגדרת הפרמטרים (באמצעות zod) כך שהסוכן ידע שהוא צריך לספק נתיב לקובץ.

משימה 5: הגדרת ה-Tool השני (list_repository_files)

כדי שהסוכן לא ינחש שמות של קבצים, הוא צריך כלי שיחזיר לו את רשימת הקבצים בתיקייה (tree). זה קריטי כדי שהוא ידע איפה לחפש.

שלב ג': אינטגרציה וליטוש (The "Wow" Factor)
כאן אנחנו מחברים את הכל לחוויה אחת חלקה.

משימה 6: לוגיקת בחירה (The Hybrid Brain)

עדכון ה-Prompt הראשי כך שהסוכן ידע: "יש לך ידע כללי עלי ב-Markdown, אבל אם שואלים על קוד ספציפי – תשתמש בכלים של GitHub".

משימה 7: מנגנון Caching בסיסי

כדי לא לחרוג ממכסות ה-API של GitHub (ולא לחכות לכל בקשה), הוסף לוגיקה ששומרת קבצים שנקראו כבר בזיכרון (Cache) לזמן קצר.

משימה 8: טיפול בשגיאות (The Safety Net)

מה קורה אם הקובץ ב-GitHub לא קיים? או אם ה-API למטה? צריך לוודא שהסוכן עונה "אני לא מוצא את הקובץ כרגע" במקום לקרוס.